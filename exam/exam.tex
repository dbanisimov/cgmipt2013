\documentclass[11pt]{article}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{graphicx}
%\usepackage{caption}
%\usepackage{subcaption}
%\usepackage{hyperref}
%\usepackage{pdfpages}
%\usepackage{gnuplot-lua-tikz}
%\usepackage{amsmath,amssymb}
\title{CGMIPT 2013 - Вопросы для зачёта}
\author{Денис Анисимов}

\pdfcompresslevel0

\begin{document}
\maketitle
\section{}
\textit{Каковы преимущества векторного представления изображения перед растровым представлением? Каковы преимущества растрового представления изображения перед векторным представлением?}

\begin{itemize}
  \item Векторное представление - представление изображений геометрическими примитивами. Преимущества:
  \begin{enumerate}
    \item Компактность представления. Для изображений, которые в основном представляют собой набор геометрических примитивов.
    \item Масштабируемость. Векторное представление описывает способ создания изображения(векторный путь), система координат которой при отрисовке может быть произвольно растянута.
    
    Одно и то же векторное представление может быть преобразовано в растровый с различным разрешением.
    \item Легче использование в векторных устройствах вывода, например плоттерах.
    \item Хорошо подходит для сжатия без потерь, т.к. являются, в основном, текстовым описанием векторов.
  \end{enumerate}
  \item Растровое представление - изображение в виде набора точек, обычно таблица в прямоугольной системе координат. Преимущества:
  \begin{itemize}
    \item Распространённые устройства вывода(мониторы, принтеры) являются растровыми устройствами. Поэтому вывод растрового изображения(если не учитывать масштабирование и обработку):
    \begin{enumerate}
      \item Быстрее - нет необходимости делать математические вычисления пути вектора.
      \item Точнее - результирующее изображение не зависит от алгоритма преобразования и на всех устройствах вывода выглядит одинаково. Нет артефактов, таких как алиасинг.
      \item Растровое представление позволяет использовать особенности вывода изображений на растровых устройствах. Пример  - хинтинг шрифтов.
    \end{enumerate}
    \item Для фотографический изображений растровое представление даёт большую точность при меньших накладных расходах.(сложные распределения пикселей трудны для представления в векторе и могут быть отрисованы с артефактами)
    \item Устройства ввода(камеры, сканеры) считывают растровое изображение. Перевод таких изображений в вектор процесс недетерминированный и не всегда практичный(см. предыдущий пункт).
  \end{itemize}
\end{itemize}

\section{}
\textit{Как определяется пространство CIE ХYZ. Какие свойства человеческого зрения делают это возможным?}

В человеческом глазе за восприятие цвета отвечают цветочувствительные клетки называемые "колбочки". Существует три типа колбочек, которые грубо можно обозначить как отвечающие за голубой(Short, 420-400мм), зелёный(Middle, 530-540мм) и красный(или оранжевый, Long, 560-580мм) цвета. Отклик этих клеток не монохроматический и поэтому в стандартных примитивах цвета RGB  некоторые видимые глазом цвета могут соответствовать отрицательным значениям веса примитива. Чтобы избежать наличия отрицательных значений были введены мнимые основные цвета XYZ. 

Другая особенность человеческого глаза - восприятие зелёного цвета как более яркого относительно синего и красного. Поэтому в XYZ модели Y считается координатой яркости и чувствительность яркости стандартного наблюдателя в модели CIE примерно соответствует отклику зелёных колбочек.

Три стандартных цвета XYZ дают трёхмерное пространство. Но для восприятия цвета человеческим глазом важно только относительные различия компонент, а абсолютные значения отвечают за яркость. Производная модель xyY использует относительные компоненты x и y и яркость Y. Цветовое пространство xy может быть представлено на плоскости в виде диаграммы-лепестка(форма следует из цветового восприятия стандартного наблюдателя).

\section{}
\textit{Пересечение кривой Безье и прямой линии. Быстрая оценка максимального количества пересечений. Алгоритм поиска пересечений.}

\begin{itemize}
  \item Быструю и грубую оценку количества пересечений можно получить посчитав пересечения прямой с фигурой, образованной линией соединяющей контрольные точки кривой.
  \item Более точно оценить можно представив кривую Безье ломаной. Например последовательно деля её пополам.

(И первый и второй способ используют свойство кривой Безье, что она всегда лежит внутри выпуклой оболочки контрольных точек.)
  \item Точное нахождение пересечения прямой с кривой Безье можно получить математически. Представить прямую уравнением от координаты $(x,y)$, кривую параметрическим уравнением. Подставить значения координат вектора из второго в первое и решить уравнение с $n$ корнями, где $n$ - порядок кривой Безье. Можно решить символьно(просто для линейных, квадратичных и кубических кривых) или приближённо, используя методы нахождение корней уравнения.
\end{itemize}

\section{}
\textit{Предсказание (экстраполяция, predictive coding) . Примеры использования в PNG и в JPEG.}

Экстраполяция - определение значения пиксела на основе уже известного. Кодируется не абсолютное значение, а его разница с предыдущим. В качестве предыдущего пиксела могут быть использованны несколько не обязательно смежных. Улучшение сжатия достигается за счёт того, что кодируемые значения имеют меньшую амплитуду и как правило постоянны(смежные пикселы в реальных изображениях редко существенно отличаются). 

В сжатии без потерь JPEG-LS используется предсказание по одному, двум или трём непосредственно соседним пикселам.(кодирование изображения происходит при проходе сверху-вниз слева-направо, поэтому эти пикселы обозначаются как север, запад и северо-запад). В формате PNG также используется предсказание по алгоритму Паета, в котором из трёх пикселов выбирается ближайший к значению \textit{север+запад - северо-запад}.

У такого кодирования разности есть недостаток - для восстановления значения в какой-то точке нужно просуммировать все разности от начального значения, т.е. кодирование не локально. Чтобы избежать этого можно применять кодирование Хаара, в котором вместе с полуразностью значений пикселов хранится их полусумма(сжатие за счёт того, что полусумм в два раза меньше и полуразности имеют малую амплитуду).

\section{}
\textit{Сравнить алгоритм буфера глубины и алгоритм ray-casting.  В чем разница? Какие есть преимущества у алгоритма ray-casting?}

Буфер глубины и трассировка лучей - алгоритмы удаления невидимых поверхностей.

\begin{itemize}
  \item Алгоритм буфера глубины использует буфер, аналогичный буферу изображения, для сохранения информации о глубине точки(расстоянию от плоскости изображения). При обработке объекта для каждой точки вычисляется её глубина, и если она меньше текущей, то значение точки в буфере изображения обновляется.
  \item Алгоритм трассировки лучей основывается на физической идее распространения света источника, отражённого от объекта, к наблюдателю. Обратная трассировка обозначает рассмотрение лучей доходящих до наблюдателя, вместо их распространения из источника. Наблюдателя можно считать бесконечно удалённым от плоскости изображения, и каждый луч проходящий через точку изображения можно считать параллельным остальным. Для каждого такого луча считаются пересечения с объектами, сортируются по глубине, и для задачи удаления невидимых плоскостей берётся ближайшее к плоскости изображения пересечение.
\end{itemize}

Трассировка лучей имеет ряд преимуществ перед буфером глубины:
\begin{itemize}
  \item Проще распараллелить, т.к. каждый луч можно обрабатывать независимо.
  \item Меньше затраты по памяти, т.к. не надо хранить буфер глубины.
  \item Проще реализовать алгоритмы сглаживания и учёта прозрачности, т.к. информация от каждого объекты для каждого пиксела строго упорядочена.
\end{itemize}
\end{document}